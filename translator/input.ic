#define F_CPU 16000000L

#include "atmega128.ih"

$ #include <avr/io.h>
$ #include <util/delay.h>
$ #include <stdint.h>
$ #include <stdio.h>
$ #include <string.h>
$ #include <stdlib.h>

#include "globals.ih"
#include "ui_subroutines.ih"
#include "spi.ih"

unsigned int number;

void test_func()
{
	int a, b;
	unsigned c=5, d=7;
	a=b+c-d;
	
	for(int i=0;i<10;i++)
	{
		a+=b;;;;
	}
	
	for(int i=0;i<10;i++)
	{
	}
}

//=============================================================================
//Процесс инициализации
//=============================================================================
process Initialization : background
{
	unsigned int counter;
	state FS_START
	{
		//DEBUG
		//TEST_DDR |= _BV(TEST_PIN);
		//TEST_PORT &= ~_BV(TEST_PIN);
	
		//TODO: Load values from EEPROM
		int i,j;
		for(i=0;i<NUM_PORTS;i++)
		{
			port_zero_values[i] = 32767;
			for(j=0;j<NUM_REG_PARAMS;j++)
			{
				port_reg_params[i][j] = 1.0;
			}
		}
		
		//Настройка вывода опорного сигнала сети на вход
		MAINS_REF_DDR &= ~_BV(MAINS_REF_PIN);
		
		//Настройка выводов управления нагревателями
		HEATER_DDR |= _BV(HEATER_A_PIN);
		HEATER_PORT |= _BV(HEATER_A_PIN);
		
		//настройка внешнего прерывания INT5 на срабатывание по восходящему 
		//фронту сигнала синхронизации сети
		EICRB |= _BV(ISC50) | _BV(ISC51);
	
		//Настройка таймера 2 для выдачи ШИМ 2.5кГц, скважность 2
		BUZZER_DDR |= _BV(BUZZER_PIN);
		OCR2 = 50;
		//делитель 1/64, режим CTC (сброс по сравнению)
		TCCR2 = _BV(WGM21) | _BV(CS21) | _BV(CS20);
		
		start process LongBuzz;
		set state Step2;
	}
	state Step2
	{	
		sreg_led = 0;
		sreg_lcd = 0;
		counter = 0;

		UI_DDR = _BV(LCD_RS_PIN) | _BV(LCLK_PIN) | _BV(DI_PIN) | _BV(SCLK_PIN) | _BV(LCD_E_PIN);
		SCLK_PORT |= _BV(SCLK_PIN); 
		LCLK_PORT |= _BV(LCLK_PIN); 
		LCD_RS_PORT |= _BV(LCD_RS_PIN); 
		LCD_E_PORT &= ~_BV(LCD_E_PIN); 
		
		InitLCD();
		
		sprintf(LCD_text, "Initializing... ");
		
		start process ShiftRegisters;
		
		set state Step3;
	}
	state Step3
	{	
		//Init USART0
		unsigned int ubrr = 8;
		UBRR0H =  ubrr >> 8;
		UBRR0L =  ubrr;
		UCSR0B = _BV(TXEN0);
		UCSR0C = _BV(UCSZ00) | _BV(UCSZ01);
		
		//Инициализация аппаратного SPI
		SPI_DDR |= _BV(SPI_SCK) | _BV(SPI_MOSI) | _BV(SPI_SS);//MOSI, SCK, SS на выход
		SPSR |= _BV(SPI2X);//двойная скорость SPI
		SPCR = _BV(SPE) | _BV(MSTR) | _BV(CPOL) | _BV(CPHA);
		
		//Настройка направления работы выводов CS, RESET и DRDY
		DDRA |= _BV(DD2_CS) | _BV(DD3_CS) | _BV(DD2_RESET) | _BV(DD3_RESET);//CS и RESET на выход
		DDRE &= ~(_BV(DD2_DRDY) | _BV(DD3_DRDY)); //DRDY на вход
		PORTA |= _BV(DD2_CS) | _BV(DD3_CS);//установка сигнала CS в 1	
		
		//настройка внешних прерываний сигналов DRDY на срабатывание по нисходящему фронту
		EICRB |= _BV(ISC61) | _BV(ISC71);
		
		//Инициализация АЦП DD2 (AD7705)
		PORTA &= ~_BV(DD2_RESET);//Перезапуск устройства
		_delay_ms(1);
		PORTA |= _BV(DD2_RESET);
		_delay_ms(1);//мин 100нс по документации
		
		//Инициализация АЦП и внутренняя калибровка канала 0
		PORTA &= ~_BV(DD2_CS);
		WriteByteSPI(ADC_WRITE | ADC_CLOCK_REG | ADC_CH0);//comm: write clock, ch0
		WriteByteSPI(ADC_CLKDIV);//Задание тактовой частоты работы АЦП (4МГц/2)
		WriteByteSPI(ADC_WRITE | ADC_SETUP_REG | ADC_CH0);//comm: write setup, ch0
		WriteByteSPI(ADC_SELF_CALIB | ADC_BIPOLAR | ADC_GAIN_128);//Запуск внутренней калибровки, gain 128
		PORTA |= _BV(DD2_CS);
		for(;PINE & _BV(DD2_DRDY););//Ожидание спада сигнала DRDY
		
		//Внутрення калибровка канала 1
		PORTA &= ~_BV(DD2_CS);
		WriteByteSPI(ADC_WRITE | ADC_SETUP_REG | ADC_CH1);//comm: write setup, ch1
		WriteByteSPI(ADC_SELF_CALIB | ADC_BIPOLAR | ADC_GAIN_128);//Запуск внутренней калибровки, gain 128, буфер отключен
		PORTA |= _BV(DD2_CS);
		
		//Инициализация АЦП DD3 (AD7705)
		PORTA &= ~_BV(DD3_RESET);//Перезапуск устройства
		_delay_ms(1);
		PORTA |= _BV(DD3_RESET);
		_delay_ms(1);//мин 100нс по документации
		
		//Инициализация АЦП и внутренняя калибровка канала 0
		PORTA &= ~_BV(DD3_CS);
		WriteByteSPI(ADC_WRITE | ADC_CLOCK_REG | ADC_CH0);//comm: write clock, ch0
		WriteByteSPI(ADC_CLKDIV);//Задание тактовой частоты работы АЦП (4МГц/2)
		WriteByteSPI(ADC_WRITE | ADC_SETUP_REG | ADC_CH0);//comm: write setup, ch0
		WriteByteSPI(ADC_SELF_CALIB | ADC_BIPOLAR | ADC_GAIN_128);//Запуск внутренней калибровки, gain 128, буфер отключен
		PORTA |= _BV(DD3_CS);
		for(;PINE & _BV(DD3_DRDY););//Ожидание спада сигнала DRDY
		
		//Внутрення калибровка канала 1
		PORTA &= ~_BV(DD3_CS);
		WriteByteSPI(ADC_WRITE | ADC_SETUP_REG | ADC_CH1);//comm: write setup, ch1
		WriteByteSPI(ADC_SELF_CALIB | ADC_UNIPOLAR | ADC_GAIN_2);//Запуск внутренней калибровки, gain 128, буфер отключен
		PORTA |= _BV(DD3_CS);
		
		dd2_adc_ch0 = 0;
		dd2_adc_ch1 = 0;
		dd3_adc_ch0 = 0;
		dd3_adc_ch1 = 0;
		
		start process DD2_ADC_Read;
		start process DD3_ADC_Read;
		start hyperprocess DD2_DRDY_interrupt;
		start hyperprocess DD3_DRDY_interrupt;
		
		set state WaitDataCorrect;
		
		
	}
	state WaitDataCorrect
	{
		bool DataCorrect;
		
		stop hyperprocess DD2_DRDY_interrupt;
		stop hyperprocess DD3_DRDY_interrupt;
		DataCorrect = (0 != dd2_adc_ch0 && 0 != dd2_adc_ch1 && 0 != dd3_adc_ch0 && 0 != dd3_adc_ch1);
		start hyperprocess DD2_DRDY_interrupt;
		start hyperprocess DD3_DRDY_interrupt;
		
		if(DataCorrect)
		{
			start process ButtonUp;
			start process ButtonDown;
			start process ButtonsUpDownHoldDetect;
			start process ButtonA;
			start process ButtonB;
			start process ButtonC;
			start process ButtonEnter;
			start process UI_Menu;
			start process UI_Setup_Switching;
			
			start process PortA_Brezenham;
			start hyperprocess MAINS_REF_interrupt;
			
			//start process TestPrint;
			//start process ADC_Test_output;
			start process CalcTempInt;
			start process CalcTempPortA;
			start process CalcTempPortB;
			start process CalcTempPortC;
			
			//start process ADC_Test_output;
			
			stop process;//остановка процесса инициализации
		}
	}
}

process CalcTempInt : background
{
	state FS_START
	{
		//TEST_PORT |= _BV(TEST_PIN);//DEBUG
		//Получение температуры внутри станции
		/*
		stop hyperprocess DD3_DRDY_interrupt;//Критическая секция
		internal_temp = dd3_adc_ch1;
		start hyperprocess DD3_DRDY_interrupt;//Конец критической секции
		*/
		
		atomic
		{
			internal_temp = dd3_adc_ch1;
		}
		
		//2500мВ - опорное напряжение АЦП в мВ
		//65535 - максимум шкалы АЦП
		//2.0 - коэффициент усиления для сигнала температуры внутри станции
		//596мВ - номинальное напряжение с датчика температуры ИОН при 25°С
		//2.0 - коэффициент изменения напряжения температурного датчика ИОН, мВ/°С
		//25°С - температура, соответсвующая номинальному напряжению 596мВ на температурном выходе ИОН
		//4.72 - калибровочное смещение
		internal_temp = ((internal_temp*2500.0)/(65535.0*2.0) - 596.0)/2.0 + 25.0 + int_temp_calib_offset;
		dtostrf(internal_temp, 5, 2, internal_temp_str);
		//TEST_PORT &= ~_BV(TEST_PIN);//DEBUG
	}
}

process CalcTempPortA : background
{
	state FS_START
	{
		set state CalcTemp;
	}
	state CalcTemp
	{
		//TEST_PORT |= _BV(TEST_PIN);//DEBUG
	
		//Получение значения температуры в порту A
		stop hyperprocess DD2_DRDY_interrupt;//Критическая секция
		port_temp[SP_PORT_A] = dd2_adc_ch0;
		start hyperprocess DD2_DRDY_interrupt;//Конец критической секции
		
		if(port_temp[SP_PORT_A] < ADC_TC_OPEN_THRESHOLD)
		{
			//32767 - ноль шкалы АЦП
			//2500 - опорное напряжение АЦП в мВ; Умножается на 2.0 дифференциальном режиме
			//128 - коэффициент усиления в АЦП для сигнала с термопары
			//65535 - максимум шкалы АЦП
			//0.041 - коэффициент Зеебека для линейной модели термопары
			port_temp[SP_PORT_A] = ((port_temp[SP_PORT_A]-32767.0)*2500.0*2.0)/(128.0*65535.0*0.041) + internal_temp;
			dtostrf(port_temp[SP_PORT_A], 6, 2, port_temp_str[SP_PORT_A]);
		}
		else
		{
			set state BadData;
		}
		//TEST_PORT &= ~_BV(TEST_PIN);//DEBUG
	}
	state BadData
	{
		if(port_temp[SP_PORT_A] < ADC_TC_OPEN_THRESHOLD)
			set state CalcTemp;
		timeout(TC_OPEN_TIMEOUT)
		{
			sp_port_status[SP_PORT_C] = SP_PORT_ERROR_TC;
			stop process DegasA;
			stop process PortA_Brezenham;
			stop process;
			start process LongBuzz;
		}
	}
}

process CalcTempPortB : background
{
	state FS_START
	{
		set state CalcTemp;
	}
	state CalcTemp
	{
		//Получение значения температуры в порту B
		stop hyperprocess DD2_DRDY_interrupt;//Критическая секция
		port_temp[SP_PORT_B] = dd2_adc_ch1;
		start hyperprocess DD2_DRDY_interrupt;//Конец критической секции
		if(port_temp[SP_PORT_B] < ADC_TC_OPEN_THRESHOLD)
		{
			//32767 - ноль шкалы АЦП
			//2500 - опорное напряжение АЦП в мВ; Умножается на 2.0 дифференциальном режиме
			//128 - коэффициент усиления в АЦП для сигнала с термопары
			//65535 - максимум шкалы АЦП
			//0.041 - коэффициент Зеебека для линейной модели термопары
			port_temp[SP_PORT_B] = ((port_temp[SP_PORT_B]-32767.0)*2500.0*2.0)/(128.0*65535.0*0.041) + internal_temp;
			dtostrf(port_temp[SP_PORT_B], 6, 2, port_temp_str[SP_PORT_B]);
		}
		else
		{
			set state BadData;
		}
	}
	state BadData
	{
		if(port_temp[SP_PORT_B] < ADC_TC_OPEN_THRESHOLD)
			set state CalcTemp;
		timeout(TC_OPEN_TIMEOUT)
		{
			sp_port_status[SP_PORT_B] = SP_PORT_ERROR_TC;
			stop process DegasB;
			stop process PortB_Brezenham;
			stop process;
			start process LongBuzz;
		}
	}
}

process CalcTempPortC : background
{
	state FS_START
	{
		set state CalcTemp;
	}
	state CalcTemp
	{
		//Получение значения температуры в порту C
		stop hyperprocess DD3_DRDY_interrupt;//Критическая секция
		port_temp[SP_PORT_C] = dd3_adc_ch0;
		start hyperprocess DD3_DRDY_interrupt;//Конец критической секции
		if(port_temp[SP_PORT_C] < ADC_TC_OPEN_THRESHOLD)
		{
			//32767 - ноль шкалы АЦП
			//2500 - опорное напряжение АЦП в мВ; Умножается на 2.0 дифференциальном режиме
			//128 - коэффициент усиления в АЦП для сигнала с термопары
			//65535 - максимум шкалы АЦП
			//0.041 - коэффициент Зеебека для линейной модели термопары
			port_temp[SP_PORT_C] = ((port_temp[SP_PORT_C]-32767.0)*2500.0*2.0)/(128.0*65535.0*0.041) + internal_temp;
			dtostrf(port_temp[SP_PORT_C], 6, 2, port_temp_str[SP_PORT_C]);
		}
		else
		{
			set state BadData;
		}
	}
	state BadData
	{
		if(port_temp[SP_PORT_C] < ADC_TC_OPEN_THRESHOLD)
			set state CalcTemp;
		timeout(TC_OPEN_TIMEOUT)
		{
			sp_port_status[SP_PORT_C] = SP_PORT_ERROR_TC;
			stop process DegasC;
			stop process PortC_Brezenham;
			stop process;
			start process LongBuzz;
		}
	}
}

/*
//=============================================================================
//Процесс отладочного вывода значений температуры с АЦП
//=============================================================================
process ADC_Test_output : background
{
	state FS_START
	{
		
		//Получение значений температуры внутри станции и в порту C
		stop hyperprocess DD3_DRDY_interrupt;//Критическая секция
		stop hyperprocess DD2_DRDY_interrupt;//Критическая секция
		$sprintf((char*)$print_buffer, "%u %u %u %u\n", $dd2_adc_ch0, $dd2_adc_ch1, $dd3_adc_ch0, $dd3_adc_ch1);
		start hyperprocess DD3_DRDY_interrupt;//Конец критической секции
		start hyperprocess DD2_DRDY_interrupt;//Конец критической секции
		
		print_buffer_length = $$strlen((char*)$print_buffer)$$;
		print_buffer_index = 0;
		
		start process Print;
		start hyperprocess USART_DataRegisterEmpty_interrupt;
		set state WaitUSART;
	}
	
	state WaitUSART
	{
		if(Print passive)
			set state Delay;
	}
	state Delay
	{
		timeout(500)
		{
			set state FS_START;
		}
	}
}
*/

#include "adc.ih"
#include "keyboard.ih"

//=============================================================================
//Процесс мигания участком текста ЖК-экрана
//=============================================================================
process Blink : background
{
	int i;
	state FS_START
	{
		//копирование всего текста экрана
		for(i=0;i<17;i++)
			Blink_text[i] = LCD_text[i];
			
		set state Show;
	}
	state Hide // символы скрыты
	{
		//замена символов в заданном диапазоне на пробелы
		for(i=blink_start_pos;i<=blink_end_pos;i++)
			Blink_text[i] = ' ';
		
		timeout(BLINK_PERIOD_MS)
		{
			set state Show;
		}
	}
	state Show // символы отображаются
	{
		//копирование актуальных символов в диапазоне
		for(i=blink_start_pos;i<=blink_end_pos;i++)
			Blink_text[i] = LCD_text[i];
		
		timeout(BLINK_PERIOD_MS)
		{
			sreg_led &= ~_BV(1);
			set state Hide;
		}
	}
}

//=============================================================================
//Процесс взаимодействия с платой индикации
//Производит обновление ЖК-экрана и светодиодов, опрос клавиатуры
//с заданным периодом (40мс/25Гц)
//=============================================================================
process ShiftRegisters : background
{
	state FS_START
	{
		//Обновление состояния светодиодов
		sreg_led = 0;
		if(SP_PORT_READY == sp_port_status[SP_PORT_A]){}
		else if(SP_PORT_DEGAS == sp_port_status[SP_PORT_A])
			sreg_led |= SREG_LED_A_GRN;
		else if(SP_PORT_FINISHED == sp_port_status[SP_PORT_A])
			sreg_led |= SREG_LED_A_GRN | SREG_LED_A_RED;
		else if(SP_PORT_ERROR_TC == sp_port_status[SP_PORT_A] || SP_PORT_ERROR_HTR == sp_port_status[SP_PORT_A])
			sreg_led |= SREG_LED_A_RED;
			
		if(SP_PORT_READY == sp_port_status[SP_PORT_B]){}
		else if(SP_PORT_DEGAS == sp_port_status[SP_PORT_B])
			sreg_led |= SREG_LED_B_GRN;
		else if(SP_PORT_FINISHED == sp_port_status[SP_PORT_B])
			sreg_led |= SREG_LED_B_GRN | SREG_LED_B_RED;
		else if(SP_PORT_ERROR_TC == sp_port_status[SP_PORT_B] || SP_PORT_ERROR_HTR == sp_port_status[SP_PORT_B])
			sreg_led |= SREG_LED_B_RED;
			
		if(SP_PORT_READY == sp_port_status[SP_PORT_C]){}
		else if(SP_PORT_DEGAS == sp_port_status[SP_PORT_C])
			sreg_led |= SREG_LED_C_GRN;
		else if(SP_PORT_FINISHED == sp_port_status[SP_PORT_C])
			sreg_led |= SREG_LED_C_GRN | SREG_LED_C_RED;
		else if(SP_PORT_ERROR_TC == sp_port_status[SP_PORT_C] || SP_PORT_ERROR_HTR == sp_port_status[SP_PORT_C])
			sreg_led |= SREG_LED_C_RED;
	
		//Обновление текста на ЖК-экране
		if(Blink active)
			UpdateLCD(Blink_text);
		else
			UpdateLCD(LCD_text);
		set state Wait;
	}
	state Wait
	{
		timeout(UI_UPDATE_PERIOD_MS)
		{
			set state FS_START;
		}
	}
}


//=============================================================================
//Процесс короткого звукового сигнала
//=============================================================================
process ShortBuzz : background
{
	state FS_START
	{
		TCCR2 |= _BV(COM20);
		set state Buzz;
	}
	state Buzz
	{
		timeout(SHORT_BUZZ_DURATION_MS)
		{
			TCCR2 &= ~_BV(COM20);
			stop process;
		}
	}
}

//=============================================================================
//Процесс длинного звукового сигнала
//=============================================================================
process LongBuzz : background
{
	state FS_START
	{
		TCCR2 |= _BV(COM20);
		set state Buzz;
	}
	state Buzz
	{
		timeout(LONG_BUZZ_DURATION_MS)
		{
			TCCR2 &= ~_BV(COM20);
			stop process;
		}
	}
}

unsigned char buzz_number;
process Buzz : background
{
	unsigned char i;
	state FS_START
	{
		i = 0;
		set state StartBuzz;
	}
	state StartBuzz
	{
		if(i < buzz_number)
		{
			start process LongBuzz;
			set state Buzz;
		}
		else
			stop process;
	}
	state Buzz
	{
		timeout(LONG_BUZZ_DURATION_MS)
		{
			set state StartBuzz;
		}
	}
}

//=============================================================================
//Процесс выбора порта дегазации
//Обрабатывает события с клавиш выбора порта
//По нажатию устанавливает текущий порт в меню пользовательского интерфейса
//По длительному нажатию запускает или останавливает процесс дегазации в порту
//=============================================================================
process UI_PortSelection : background
{
	state FS_START
	{
		if(button_A_pressed)
		{
			UI_port = SP_PORT_A;
			if(UI_Menu active)
				start process UI_Menu;//сброс процесса меню на начальную страницу
		}
		if(button_B_pressed)
		{
			UI_port = SP_PORT_B;
			if(UI_Menu active)
				start process UI_Menu;//сброс процесса меню на начальную страницу
		}
		if(button_C_pressed)
		{
			UI_port = SP_PORT_C;
			if(UI_Menu active)
				start process UI_Menu;//сброс процесса меню на начальную страницу
		}
		
		
		if(button_A_held)
		{
			if(DegasA active)
			{
				stop process DegasA;
				sp_port_status[SP_PORT_A] = SP_PORT_READY;
			}
			else
			{
				start process DegasA;
				sp_port_status[SP_PORT_A] = SP_PORT_DEGAS;
			}
		}
		if(button_B_held)
		{
			if(DegasB active)
			{
				stop process DegasB;
				sp_port_status[SP_PORT_B] = SP_PORT_READY;
			}
			else
			{
				start process DegasB;
				sp_port_status[SP_PORT_B] = SP_PORT_DEGAS;
			}
		}
		if(button_C_held)
		{
			if(DegasC active)
			{
				stop process DegasC;
				sp_port_status[SP_PORT_C] = SP_PORT_READY;
			}
			else
			{
				start process DegasC;
				sp_port_status[SP_PORT_C] = SP_PORT_DEGAS;
			}
		}
	}
}


process UI_Setup_Switching : background
{
	state FS_START
	{
		if(UI_Setup_Menu active)
			set state InSetup;
		
		else
			set state InUI;
	}
	
	state InUI
	{
		if(setup_switch_combination)
		{
			stop process UI_Menu;
			start process UI_Setup_Menu;
			set state InSetup;
		}
	}
	
	state InSetup
	{
		if(setup_switch_combination)
		{
			stop process UI_Setup_Menu;
			start process UI_Menu;
			set state InUI;
		}
	}
}


#include "ui_menu.ih"
#include "ui_setup_menu.ih"

//=============================================================================
//Процесс дегазации в порту A
//=============================================================================
process DegasA : background 
{
	state FS_START 
	{
		//sreg_led &= ~SREG_LED_A_RED;
		//sreg_led |= SREG_LED_A_GRN;
	} 
	state FS_STOP
	{
		//sreg_led &= ~SREG_LED_A_GRN;
		//sreg_led |= SREG_LED_A_RED;
	}
}

//=============================================================================
//Процесс дегазации в порту B
//=============================================================================
process DegasB : background 
{
	state FS_START 
	{
		//sreg_led &= ~SREG_LED_B_RED;
		//sreg_led |= SREG_LED_B_GRN;
	} 
	state FS_STOP
	{
		//sreg_led &= ~SREG_LED_B_GRN;
		//sreg_led |= SREG_LED_B_RED;
	}
}

//=============================================================================
//Процесс дегазации в порту C
//=============================================================================
process DegasC : background 
{
	state FS_START 
	{
		//sreg_led &= ~SREG_LED_C_RED;
		//sreg_led |= SREG_LED_C_GRN;
	} 
	state FS_STOP
	{
		//sreg_led &= ~SREG_LED_C_GRN;
		//sreg_led |= SREG_LED_C_RED;
	}
}

/*process TestSPI : background
{
	unsigned char data;
	state FS_START
	{
		data = 0b00001001;
		SPDR = data;
		data = 0;//
		set state WaitTransmit;
	}
	state WaitTransmit
	{
		if(SPSR & _BV(SPIF)
		{
			set state Receive;
		}
	}
	state Receive
	{
		if(SPSR & )
	}
}*/

process TestPrint : background
{
	state FS_START
	{
		$sprintf((char*)$print_buffer, "ADC: %u\n", $number);
		//$ itoa( val, (char*)print_buffer, 10);
		print_buffer_length = $$strlen((char*)$print_buffer)$$;
		print_buffer_index = 0;
		
		start process Print;
		start hyperprocess USART_DataRegisterEmpty_interrupt;
		set state Delay;
	}
	state Delay
	{
		timeout(500)
		{
			set state FS_START;
		}
	}
}

//=============================================================================
//Гиперпроцесс внешнего прерывания по восходящему фронту опорного сигнала сети
//=============================================================================
hyperprocess MAINS_REF_interrupt
{
	vector = INT5_vect;
	register = EIMSK;
	bit = INT5;
}

//=============================================================================
//Процесс управления мощностью нагревателя порта A по алгоритму Брезенхема
//Активируется внешним прерыванием по восходящем фронту сигнала синхронизации 
//сети 100Гц, ширина импульса 760 мкс, центр импульса совпадает с моментом
//пересечения нуля синусоидальным сигналом сети 220 В
//На каждом шаге принимается решение о пропуске очередной полуволны
// - значение мощности нагревателя задается числом от 0 до 1
// - на каждом шаге к ошибке прибавляется заданная мощность
// - если ошибка >= 1, пропускаем полуволну, от ошибки отнимается 1
// - если ошибка < 1, полуволну не пропускаем
//=============================================================================
process PortA_Brezenham : MAINS_REF_interrupt
{
	volatile unsigned int error;
	state FS_START
	{
		portA_power = HEATER_FULL_POWER * 1;
		error = 0;
		//HEATER_PORT &= ~_BV(HEATER_A_PIN);
		set state Brezenham;
	}
	state Brezenham
	{
		error += portA_power;
		if(error >= HEATER_FULL_POWER)
		{
			HEATER_PORT &= ~_BV(HEATER_A_PIN);//открытие тиристора - пропускаем полуволну
			error -= HEATER_FULL_POWER;
		}
		else
			HEATER_PORT |= _BV(HEATER_A_PIN);//закрытие тиристора - не пропускаем полуволну
		//set state FS_START;
	} 
	state FS_STOP
	{
		HEATER_PORT |= _BV(HEATER_A_PIN);
	}
}

process PortB_Brezenham : MAINS_REF_interrupt
{
	unsigned int error;
	state FS_START
	{
		
	}
}

process PortC_Brezenham : MAINS_REF_interrupt
{
	unsigned int error;
	state FS_START
	{
		
	}
}

#include "print.ih"






