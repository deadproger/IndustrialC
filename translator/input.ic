#define F_CPU 16000000L

#include "atmega128.ih"

$ #include <avr/io.h>
$ #include <util/delay.h>
$ #include <stdint.h>
$ #include <stdio.h>
$ #include <string.h>

#include "globals.ih"
#include "ui_subroutines.ih"
#include "spi.ih"

unsigned int number;


void quadrupopel(int a)
{
	int c;
	a = 5;
	c = 10;
	{
		int b;
		b = 12;	
	}
}


//=============================================================================
//Процесс инициализации
//=============================================================================
process Initialization : background
{
	unsigned int counter;
	state FS_START
	{
		//Настройка таймера 2 для выдачи ШИМ 2.5кГц, скважность 2
		BUZZER_DDR |= _BV(BUZZER_PIN);
		OCR2 = 50;
		//делитель 1/64, режим CTC (сброс по сравнению)
		TCCR2 = _BV(WGM21) | _BV(CS21) | _BV(CS20);
		
		sreg_led = 0;
		sreg_lcd = 0;
		counter = 0;

		UI_DDR = _BV(LCD_RS_PIN) | _BV(LCLK_PIN) | _BV(DI_PIN) | _BV(SCLK_PIN) | _BV(LCD_E_PIN);
		SCLK_PORT |= _BV(SCLK_PIN); 
		LCLK_PORT |= _BV(LCLK_PIN); 
		LCD_RS_PORT |= _BV(LCD_RS_PIN); 
		LCD_E_PORT &= ~_BV(LCD_E_PIN); 
		
		InitLCD();
		
		//Init USART0
		unsigned int ubrr = 8;
		UBRR0H =  ubrr >> 8;
		UBRR0L =  ubrr;
		UCSR0B = _BV(TXEN0);
		UCSR0C = _BV(UCSZ00) | _BV(UCSZ01);
		
		//Инициализация аппаратного SPI
		SPI_DDR = _BV(SPI_SCK) | _BV(SPI_MOSI) | _BV(SPI_SS);//MOSI, SCK, SS на выход
		SPSR |= _BV(SPI2X);//двойная скорость SPI
		SPCR = _BV(SPE) | _BV(MSTR) | _BV(CPOL) | _BV(CPHA);
		
		//Настройка направления работы выводов CS, RESET и DRDY
		DDRA = _BV(DD2_CS) | _BV(DD3_CS) | _BV(DD2_RESET) | _BV(DD3_RESET);//CS и RESET на выход
		DDRE &= ~(_BV(DD2_DRDY) | _BV(DD3_DRDY)); //DRDY на вход
		PORTA |= _BV(DD2_CS) | _BV(DD3_CS);//установка сигнала CS в 1	
		
		//настройка внешних прерываний сигналов DRDY на срабатывание по нисходящему фронту
		EICRB = _BV(ISC61) | _BV(ISC71);
		
		//Инициализация АЦП DD2 (AD7705)
		PORTA &= ~_BV(DD2_RESET);//Перезапуск устройства
		_delay_ms(200);
		PORTA |= _BV(DD2_RESET);
		
		_delay_ms(200);
		
		//Инициализация АЦП и внутренняя калибровка канала 0
		PORTA &= ~_BV(DD2_CS);
		WriteByteSPI(ADC_WRITE | ADC_CLOCK_REG | ADC_CH0);//comm: write clock, ch0
		WriteByteSPI(ADC_CLKDIV);//Задание тактовой частоты работы АЦП (4МГц/2)
		WriteByteSPI(ADC_WRITE | ADC_SETUP_REG | ADC_CH0);//comm: write setup, ch0
		WriteByteSPI(ADC_SELF_CALIB | ADC_BIPOLAR | ADC_GAIN_128);//Запуск внутренней калибровки, gain 128
		PORTA |= _BV(DD2_CS);
		for(;PINE & _BV(DD2_DRDY););//Ожидание спада сигнала DRDY
		
		//Внутрення калибровка канала 1
		PORTA &= ~_BV(DD2_CS);
		WriteByteSPI(ADC_WRITE | ADC_SETUP_REG | ADC_CH1);//comm: write setup, ch1
		WriteByteSPI(ADC_SELF_CALIB | ADC_BIPOLAR | ADC_GAIN_128);//Запуск внутренней калибровки, gain 128, буфер отключен
		PORTA |= _BV(DD2_CS);
		
		
		//Инициализация АЦП DD3 (AD7705)
		PORTA &= ~_BV(DD3_RESET);//Перезапуск устройства
		_delay_ms(200);
		PORTA |= _BV(DD3_RESET);
		_delay_ms(200);
		
		//Инициализация АЦП и внутренняя калибровка канала 0
		PORTA &= ~_BV(DD3_CS);
		WriteByteSPI(ADC_WRITE | ADC_CLOCK_REG | ADC_CH0);//comm: write clock, ch0
		WriteByteSPI(ADC_CLKDIV);//Задание тактовой частоты работы АЦП (4МГц/2)
		WriteByteSPI(ADC_WRITE | ADC_SETUP_REG | ADC_CH0);//comm: write setup, ch0
		WriteByteSPI(ADC_SELF_CALIB | ADC_BIPOLAR | ADC_GAIN_128);//Запуск внутренней калибровки, gain 128, буфер отключен
		PORTA |= _BV(DD3_CS);
		for(;PINE & _BV(DD3_DRDY););//Ожидание спада сигнала DRDY
		
		//Внутрення калибровка канала 1
		PORTA &= ~_BV(DD3_CS);
		WriteByteSPI(ADC_WRITE | ADC_SETUP_REG | ADC_CH1);//comm: write setup, ch1
		WriteByteSPI(ADC_SELF_CALIB | ADC_UNIPOLAR | ADC_GAIN_2);//Запуск внутренней калибровки, gain 128, буфер отключен
		PORTA |= _BV(DD3_CS);
		
		//Запуск процессов чтения АЦП и прерываний сигналов DRDY
		//start process DD2_ADC_Read;
		//start process DD3_ADC_Read;
		//start hyperprocess DD2_DRDY_interrupt;
		//start hyperprocess DD3_DRDY_interrupt;
		
		//start process ShiftRegisters;
		//start process ButtonUp;
		//start process ButtonDown;
		//start process ButtonA;
		//start process ButtonB;
		//start process ButtonC;
		//start process ButtonEnter;
		//start process UI_Menu;
		
		//start process TestPrint;
		
		stop process;//остановка процесса инициализации
	}
}

/*
process ADC_Test_output : background
{
	state FS_START
	{
		float int_temp;
		float portA_temp;
		
		stop hyperprocess DD3_DRDY_interrupt;
		int_temp = dd3_adc_ch1;
		start hyperprocess DD3_DRDY_interrupt;
		
		int_temp = ((int_temp*2500)/(65535.0*2.0) - 596)/2.0 + 25 - 4.72;
		char int_temp_str[16];
		dtostrf(int_temp, 5, 2, int_temp_str);
		
		stop hyperprocess DD2_DRDY_interrupt;
		portA_temp = dd2_adc_ch0;
		start hyperprocess DD2_DRDY_interrupt;
		
		portA_temp = ((portA_temp-32767)*2500*2)/(128*65535*0.041) + int_temp;
		char portA_temp_str[16];
		dtostrf(portA_temp, 5, 2, portA_temp_str);
		
		stop hyperprocess DD2_DRDY_interrupt;//Критическая секция отн-но прерываний DRDY
		stop hyperprocess DD3_DRDY_interrupt;
		$sprintf((char*)$print_buffer, "%s %u %u %s\n", $portA_temp_str, 32000, $dd3_adc_ch0, $int_temp_str);
		start hyperprocess DD2_DRDY_interrupt;
		start hyperprocess DD3_DRDY_interrupt;//Конец критической секции
		
		print_buffer_length = $$strlen((char*)$print_buffer)$$;
		print_buffer_index = 0;
		
		start process Print;
		start hyperprocess USART_DataRegisterEmpty_interrupt;
		to state WaitUSART;
	}
	
	state WaitUSART
	{
		if(Print passive)
			to state Delay;
	}
	state Delay
	{
		timeout(500)
		{
			to state FS_START;
		}
	}
}
*/
//#include "adc.ih"


hyperprocess DD2_DRDY_interrupt
{
	vector = INT6_vect;
	register = EIMSK;
	bit = INT6;
}

process ISRProc_with_no_timeouts : DD2_DRDY_interrupt
{
	state FS_START
	{
	}
}

process DD2_ADC_Read : DD2_DRDY_interrupt
{
	state FS_START
	{
		timeout(500)
		{
			1;
			to state State2;
		}
	}
	
	state State2
	{
	
	}
	state State3
	{
		timeout(1000)
		{
			to state FS_START;
		}	
	}
}


#include "keyboard.ih"

//=============================================================================
//Процесс мигания участком текста ЖК-экрана
//=============================================================================
process Blink : background
{
	int i;
	state FS_START
	{
		//копирование всего текста экрана
		for(i=0;i<16;i++)
			Blink_text[i] = LCD_text[i];
			
		to state Show;
	}
	state Hide // символы скрыты
	{
		//замена символов в заданном диапазоне на пробелы
		for(i=blink_start_pos;i<=blink_end_pos;i++)
			Blink_text[i] = ' ';
		
		timeout(BLINK_PERIOD_MS)
		{
			to state Show;
		}
	}
	state Show // символы отображаются
	{
		//копирование актуальных символов в диапазоне
		for(i=blink_start_pos;i<=blink_end_pos;i++)
			Blink_text[i] = LCD_text[i];
		
		timeout(BLINK_PERIOD_MS)
		{
			sreg_led &= ~_BV(1);
			to state Hide;
		}
	}
}

//=============================================================================
//Процесс взаимодействия с платой индикации
//Производит обновление ЖК-экрана и светодиодов, опрос клавиатуры
//с заданным периодом (40мс/25Гц)
//=============================================================================
process ShiftRegisters : background
{
	state FS_START
	{
		if(Blink active)
			UpdateLCD(Blink_text);
		else
			UpdateLCD(LCD_text);
		to state Wait;
	}
	state Wait
	{
		timeout(UI_UPDATE_PERIOD_MS)
		{
			to state FS_START;
		}
	}
}


//=============================================================================
//Процесс короткого звукового сигнала
//=============================================================================
process ShortBuzz : background
{
	state FS_START
	{
		TCCR2 |= _BV(COM20);
		to state Buzz;
	}
	state Buzz
	{
		timeout(SHORT_BUZZ_DURATION_MS)
		{
			TCCR2 &= ~_BV(COM20);
			stop process;
		}
	}
}


//=============================================================================
//Процесс выбора порта дегазации
//Обрабатывает события с клавиш выбора порта
//По нажатию устанавливает текущий порт в меню пользовательского интерфейса
//По длительному нажатию запускает или останавливает процесс дегазации в порту
//=============================================================================
process UI_PortSelection : background
{
	state FS_START
	{
		if(button_A_pressed)
		{
			UI_port = PORT_A;
			start process UI_Menu;
		}
		if(button_B_pressed)
		{
			UI_port = PORT_B;
			start process UI_Menu;
		}
		if(button_C_pressed)
		{
			UI_port = PORT_C;
			start process UI_Menu;
		}
		
		if(button_A_held)
		{
			if(DegasA active)
				stop process DegasA;
			else
				start process DegasA;
		}
		if(button_B_held)
		{
			if(DegasB active)
				stop process DegasB;
			else
				start process DegasB;
		}
		if(button_C_held)
		{
			if(DegasC active)
				stop process DegasC;
			else
				start process DegasC;
		}
	}
}

//=============================================================================
//Процесс обработки меню пользовательского интерфейса
//=============================================================================
process UI_Menu : background
{	
	unsigned int new_temp;//редактируемое значение температуры
	unsigned int new_time;//редактируемое значение вермени

	state FS_START
	{
		start process UI_PortSelection;
		to state DisplayPortStatus;
	}
	
	state DisplayPortStatus // Отображение состояния порта
	{	
		sprintf(LCD_text, "%c:Status       *", PORT_NAME[UI_port]);
		if(button_up_pressed)
			to state DisplayTemp;
	}
	
	state DisplayTemp // Отображение заданной температуры дегазации в порту
	{
		sprintf(LCD_text, "%c:Temp.ust=%3u C", PORT_NAME[UI_port], TempValues[UI_port]);
		LCD_text[14] = 0;
		if(button_up_pressed)
			to state DisplayTime;
		if(button_down_pressed)
			to state DisplayPortStatus;
		if(button_Enter_pressed)
		{
			stop process UI_PortSelection;
			blink_start_pos = 11;
			blink_end_pos = 13;
			start process Blink;
			to state EditTemp;
			new_temp = TempValues[UI_port];
		}
	}
	
	state DisplayTime // Отображение заданного времени дегазации в порту
	{
		sprintf(LCD_text, "%c:Time.dg=%3umin", PORT_NAME[UI_port], TimeValues[UI_port]);
		if(button_up_pressed)
			to state DisplayIntTemp;
		if(button_down_pressed)
			to state DisplayTemp;
		if(button_Enter_pressed)
		{
			stop process UI_PortSelection;
			blink_start_pos = 10;
			blink_end_pos = 12;
			start process Blink;
			to state EditTime;
			new_time = TimeValues[UI_port];
		}
	}
	
	state DisplayIntTemp // Отображение температур внутри станции
	{
		sprintf(LCD_text, "Int.Temperature*");
		if(button_down_pressed)
			to state DisplayTime;
	}
	
	state EditTemp // Редактирование температуры дегазации порта
	{
		sprintf(LCD_text, "%c:Temp.ust=%3u C", PORT_NAME[UI_port], new_temp);
		LCD_text[14] = 0;
		if(button_Enter_pressed)
		{
			start process UI_PortSelection;
			stop process Blink;
			to state DisplayTemp;
			TempValues[UI_port] = new_temp;
		}
		
		if(button_up_pressed)
		{
			new_temp += STEP_TEMP;
			if(new_temp > MAX_TEMP)
				new_temp = MAX_TEMP;
				
			start process Blink;
			to state EditTemp;
		}
		if(button_down_pressed)
		{
			new_temp -= STEP_TEMP;
			if(new_temp < MIN_TEMP)
				new_temp = MIN_TEMP;
				
			start process Blink;
			to state EditTemp;
		}
			
		timeout(EDIT_TIMEOUT_MS)
		{
			start process UI_PortSelection;
			stop process Blink;
			to state DisplayTemp;
		}
	}
	
	state EditTime // Редактирование времени дегазации порта
	{
		sprintf(LCD_text, "%c:Time.dg=%3umin", PORT_NAME[UI_port], new_time);
		if(button_Enter_pressed)
		{
			start process UI_PortSelection;
			stop process Blink;
			to state DisplayTime;
			TimeValues[UI_port] = new_time;
		}
		
		if(button_up_pressed)
		{
			new_time += STEP_TIME;
			if(new_time > MAX_TIME)
				new_time = MAX_TIME;
			start process Blink;
			to state EditTime;
		}
		if(button_down_pressed)
		{
			new_time -= STEP_TIME;
			if(new_time < MIN_TIME)
				new_time = MIN_TIME;
			start process Blink;
			to state EditTime;
		}
			
		timeout(EDIT_TIMEOUT_MS)
		{
			start process UI_PortSelection;
			stop process Blink;
			to state DisplayTime;
		}
	}
	
}


//=============================================================================
//Процесс дегазации в порту A
//=============================================================================
process DegasA : background 
{
	state FS_START 
	{
		sreg_led &= ~SREG_LED_A_RED;
		sreg_led |= SREG_LED_A_GRN;
	} 
	state FS_STOP
	{
		sreg_led &= ~SREG_LED_A_GRN;
		sreg_led |= SREG_LED_A_RED;
	}
}

//=============================================================================
//Процесс дегазации в порту B
//=============================================================================
process DegasB : background 
{
	state FS_START 
	{
		sreg_led &= ~SREG_LED_B_RED;
		sreg_led |= SREG_LED_B_GRN;
	} 
	state FS_STOP
	{
		sreg_led &= ~SREG_LED_B_GRN;
		sreg_led |= SREG_LED_B_RED;
	}
}

//=============================================================================
//Процесс дегазации в порту C
//=============================================================================
process DegasC : background 
{
	state FS_START 
	{
		sreg_led &= ~SREG_LED_C_RED;
		sreg_led |= SREG_LED_C_GRN;
	} 
	state FS_STOP
	{
		sreg_led &= ~SREG_LED_C_GRN;
		sreg_led |= SREG_LED_C_RED;
	}
}

process some201709030522_1 : background
{
	state FS_START
	{
	}
}

process some201709030522_2 : background
{
	state FS_START
	{
	}
}

process some201709030522_3 : background
{
	state FS_START
	{
	}
}

process some201709030522_4 : background
{
	state FS_START
	{
	}
}

process some201709030522_5 : background
{
	state FS_START
	{
	}
}

/*
process TestPrint : background
{
	state FS_START
	{
		$sprintf((char*)$print_buffer, "ADC: %u\n", $number);
		//$ itoa( val, (char*)print_buffer, 10);
		print_buffer_length = $$strlen((char*)$print_buffer)$$;
		print_buffer_index = 0;
		
		//start process Print;
		//start hyperprocess USART_DataRegisterEmpty_interrupt;
		to state Delay;
	}
	state Delay
	{
		timeout(500)
		{
			to state FS_START;
		}
	}
}
*/
//#include "print.ih"






