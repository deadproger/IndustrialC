#define F_CPU 16000000L

#include "../headers/atmega128.ih"

$ #include <avr/io.h>
$ #include <util/delay.h>
$ #include <stdint.h>
$ #include <stdio.h>
$ #include <string.h>
$ #include <stdlib.h>

#include "globals.ih"
#include "ui_subroutines.ih"
#include "spi.ih"

unsigned int number;

//=============================================================================
//Процесс инициализации
//=============================================================================
process Initialization : background
{
	unsigned int counter;
	state FS_START
	{
		//DEBUG
		TEST_DDR |= _BV(TEST_PIN);
		TEST_PORT &= ~_BV(TEST_PIN);
	
		//TODO: Load values from EEPROM
		for(int i=0;i<NUM_PORTS;i++)
		{
			port_zero_values[i] = 32767;
			for(int j=0;j<NUM_REG_PARAMS;j++)
			{
				port_reg_params[i][j] = 1.0;
			}
		}
		
		//Настройка вывода опорного сигнала сети на вход
		MAINS_REF_DDR &= ~_BV(MAINS_REF_PIN);
		
		//Настройка выводов управления нагревателями
		HEATER_DDR |= _BV(HEATER_A_PIN);
		HEATER_PORT |= _BV(HEATER_A_PIN);
		
		//настройка внешнего прерывания INT5 на срабатывание по восходящему 
		//фронту сигнала синхронизации сети
		EICRB |= _BV(ISC50) | _BV(ISC51);
	
		//Настройка таймера 2 для выдачи ШИМ 2.5кГц, скважность 2
		BUZZER_DDR |= _BV(BUZZER_PIN);
		OCR2 = 50;
		//делитель 1/64, режим CTC (сброс по сравнению)
		TCCR2 = _BV(WGM21) | _BV(CS21) | _BV(CS20);
		
		start process LongBuzz;
		set state Step2;
	}
	state Step2
	{	
		sreg_led = 0;
		sreg_lcd = 0;
		counter = 0;

		UI_DDR = _BV(LCD_RS_PIN) | _BV(LCLK_PIN) | _BV(DI_PIN) | _BV(SCLK_PIN) | _BV(LCD_E_PIN);
		SCLK_PORT |= _BV(SCLK_PIN); 
		LCLK_PORT |= _BV(LCLK_PIN); 
		LCD_RS_PORT |= _BV(LCD_RS_PIN); 
		LCD_E_PORT &= ~_BV(LCD_E_PIN); 
		
		InitLCD();
		
		sprintf(LCD_text, "Initializing... ");
		
		start process ShiftRegisters;
		
		set state Step3;
	}
	state Step3
	{	
		//Init USART0
		unsigned int ubrr = 8;
		UBRR0H =  ubrr >> 8;
		UBRR0L =  ubrr;
		UCSR0B = _BV(TXEN0);
		UCSR0C = _BV(UCSZ00) | _BV(UCSZ01);
		
		//Инициализация аппаратного SPI
		SPI_DDR |= _BV(SPI_SCK) | _BV(SPI_MOSI) | _BV(SPI_SS);//MOSI, SCK, SS на выход
		SPSR |= _BV(SPI2X);//двойная скорость SPI
		SPCR = _BV(SPE) | _BV(MSTR) | _BV(CPOL) | _BV(CPHA);
		
		//Настройка направления работы выводов CS, RESET и DRDY
		DDRA |= _BV(DD2_CS) | _BV(DD3_CS) | _BV(DD2_RESET) | _BV(DD3_RESET);//CS и RESET на выход
		DDRE &= ~(_BV(DD2_DRDY) | _BV(DD3_DRDY)); //DRDY на вход
		PORTA |= _BV(DD2_CS) | _BV(DD3_CS);//установка сигнала CS в 1	
		
		//настройка внешних прерываний сигналов DRDY на срабатывание по нисходящему фронту
		EICRB |= _BV(ISC61) | _BV(ISC71);
		
		//Инициализация АЦП DD2 (AD7705)
		PORTA &= ~_BV(DD2_RESET);//Перезапуск устройства
		_delay_ms(1);
		PORTA |= _BV(DD2_RESET);
		_delay_ms(1);//мин 100нс по документации
		
		//Инициализация АЦП и внутренняя калибровка канала 0
		PORTA &= ~_BV(DD2_CS);
		WriteByteSPI(ADC_WRITE | ADC_CLOCK_REG | ADC_CH0);//comm: write clock, ch0
		WriteByteSPI(ADC_CLKDIV);//Задание тактовой частоты работы АЦП (4МГц/2)
		WriteByteSPI(ADC_WRITE | ADC_SETUP_REG | ADC_CH0);//comm: write setup, ch0
		WriteByteSPI(ADC_SELF_CALIB | ADC_BIPOLAR | ADC_GAIN_128);//Запуск внутренней калибровки, gain 128
		PORTA |= _BV(DD2_CS);
		for(;PINE & _BV(DD2_DRDY););//Ожидание спада сигнала DRDY
		
		//Внутрення калибровка канала 1
		PORTA &= ~_BV(DD2_CS);
		WriteByteSPI(ADC_WRITE | ADC_SETUP_REG | ADC_CH1);//comm: write setup, ch1
		WriteByteSPI(ADC_SELF_CALIB | ADC_BIPOLAR | ADC_GAIN_128);//Запуск внутренней калибровки, gain 128, буфер отключен
		PORTA |= _BV(DD2_CS);
		
		//Инициализация АЦП DD3 (AD7705)
		PORTA &= ~_BV(DD3_RESET);//Перезапуск устройства
		_delay_ms(1);
		PORTA |= _BV(DD3_RESET);
		_delay_ms(1);//мин 100нс по документации
		
		//Инициализация АЦП и внутренняя калибровка канала 0
		PORTA &= ~_BV(DD3_CS);
		WriteByteSPI(ADC_WRITE | ADC_CLOCK_REG | ADC_CH0);//comm: write clock, ch0
		WriteByteSPI(ADC_CLKDIV);//Задание тактовой частоты работы АЦП (4МГц/2)
		WriteByteSPI(ADC_WRITE | ADC_SETUP_REG | ADC_CH0);//comm: write setup, ch0
		WriteByteSPI(ADC_SELF_CALIB | ADC_BIPOLAR | ADC_GAIN_128);//Запуск внутренней калибровки, gain 128, буфер отключен
		PORTA |= _BV(DD3_CS);
		for(;PINE & _BV(DD3_DRDY););//Ожидание спада сигнала DRDY
		
		//Внутрення калибровка канала 1
		PORTA &= ~_BV(DD3_CS);
		WriteByteSPI(ADC_WRITE | ADC_SETUP_REG | ADC_CH1);//comm: write setup, ch1
		WriteByteSPI(ADC_SELF_CALIB | ADC_UNIPOLAR | ADC_GAIN_2);//Запуск внутренней калибровки, gain 128, буфер отключен
		PORTA |= _BV(DD3_CS);
		
		dd2_adc_ch0 = 0;
		dd2_adc_ch1 = 0;
		dd3_adc_ch0 = 0;
		dd3_adc_ch1 = 0;
		
		start process DD2_ADC_Read;
		start process DD3_ADC_Read;
		start hyperprocess DD2_DRDY_interrupt;
		start hyperprocess DD3_DRDY_interrupt;
		
		set state WaitDataCorrect;
		
		
	}
	state WaitDataCorrect
	{
		bool DataCorrect;
		atomic DataCorrect = (0 != dd2_adc_ch0 && 0 != dd2_adc_ch1 && 0 != dd3_adc_ch0 && 0 != dd3_adc_ch1);
		
		if(DataCorrect)
		{
			start process ButtonUp;
			start process ButtonDown;
			start process ButtonsUpDownHoldDetect;
			start process ButtonA;
			start process ButtonB;
			start process ButtonC;
			start process ButtonEnter;
			start process UI_Menu;
			start process UI_Setup_Switching;
			
			start process PortA_Brezenham;
			start hyperprocess MAINS_REF_interrupt;
			
			//start process TestPrint;
			//start process ADC_Test_output;
			start process CalcTempInt;
			start process CalcTempPortA;
			start process CalcTempPortB;
			start process CalcTempPortC;
			
			//start process ADC_Test_output;
			
			stop process;//остановка процесса инициализации
		}
	}
}

	const unsigned long ADCREF_T_NOMINAL = 25;
	const unsigned long ADCREF_T_NOMINAL_VOLTAGE_MV = 596;//596мВ - номинальное напряжение с датчика температуры ИОН при 25°С
	const unsigned long ADCREF_T_RATE_MV_PER_DEG = 2;
	unsigned long int_calib_offset = 309330;
	//const unsigned long ADC_SCALE_MAX = 65535;//65535 - максимум шкалы АЦП
	const unsigned long ADCREF_VOLTAGE_MV = 2500;//2500мВ - опорное напряжение АЦП в мВ
	const unsigned long ADC_INT_TEMP_GAIN = 2;//2.0 - коэффициент усиления для сигнала температуры внутри станции
	const unsigned long MULTIPLIER = 0xffff;
	const unsigned long HALF_MULTIPLIER = MULTIPLIER >> 1;

process CalcTempInt : background
{
	
	
	//2.0 - коэффициент изменения напряжения температурного датчика ИОН, мВ/°С
	//25°С - температура, соответствующая номинальному напряжению 596мВ на температурном выходе ИОН
	//4.72 - калибровочное смещение
	
	state FS_START
	{
		
		/*
		atomic internal_temp = dd3_adc_ch1;//Получение температуры внутри станции
		TEST_PORT |= _BV(TEST_PIN);//DEBUG
		internal_temp = ((internal_temp*2500.0)/(65535.0*2.0) - 596.0)/2.0 + 25.0 + int_temp_calib_offset;
		TEST_PORT &= ~_BV(TEST_PIN);//DEBUG
		dtostrf(internal_temp, 5, 2, internal_temp_str);
		*/
		
		
		atomic internal_temp_xffff = dd3_adc_ch1;
		internal_temp_xffff *= ADCREF_VOLTAGE_MV;
		internal_temp_xffff /= ADCREF_T_RATE_MV_PER_DEG  * ADC_INT_TEMP_GAIN;
		internal_temp_xffff += ADCREF_T_NOMINAL << 16;
		internal_temp_xffff -= int_calib_offset;
		internal_temp_xffff -= (ADCREF_T_NOMINAL_VOLTAGE_MV << 16) / ADCREF_T_RATE_MV_PER_DEG;
		
		unsigned long cents;
		cents = internal_temp_xffff;
		cents &= 0xffff;
		cents *= 100;
		cents >>= 16;
		
		sprintf(internal_temp_str, "%02lu.%02lu", internal_temp_xffff >> 16, cents);
		
		
		
	}
}

process CalcTempPortA : background
{
	state FS_START
	{
		set state CalcTemp;
	}
	state CalcTemp
	{
		//TEST_PORT |= _BV(TEST_PIN);//DEBUG
	
		//Получение значения температуры в порту A
		unsigned int port_temp_integer;
		atomic port_temp[SP_PORT_A] = dd2_adc_ch0;
		atomic port_temp_integer = dd2_adc_ch0;
		
		if(port_temp[SP_PORT_A] < ADC_TC_OPEN_THRESHOLD)
		{
			//32767 - ноль шкалы АЦП
			//2500 - опорное напряжение АЦП в мВ; Умножается на 2.0 в дифференциальном режиме
			//128 - коэффициент усиления в АЦП для сигнала с термопары
			//65535 - максимум шкалы АЦП
			//0.041 - коэффициент Зеебека для линейной модели термопары
			//port_temp[SP_PORT_A] = ((port_temp[SP_PORT_A]-32767.0)*2500.0*2.0)/(128.0*65535.0*0.041) + internal_temp;
			//dtostrf(port_temp[SP_PORT_A], 6, 2, port_temp_str[SP_PORT_A]);
			
			const unsigned long K = 0.041*65536.0 + 0.5;
			const unsigned long Zero = 32767;
			//ADCREF_VOLTAGE_MV 2500
			const unsigned long VScale = 2500 * 2;
			const unsigned long gain = 128;
			
			unsigned long ZShift = Zero;
			ZShift *= K;
			ZShift <<= 4
			ZShift >>= 16;// /65535
			ZShift *= VScale;
			ZShift /= gain;
			ZShift >>= 4;
			
			unsigned long temp = port_temp[SP_PORT_A];
			temp *= K;
			temp <<= 4;
			temp >>= 16;
			temp *= VScale;
			temp /= gain;
			temp >>= 4;
			temp += internal_temp_xffff;
			temp -= ZShift;
			
			unsigned long cents;
			cents = temp;
			cents &= 0xffff;
			cents *= 100;
			cents >>= 16;
			
			//sprintf(port_temp_str[SP_PORT_A], "%02lu.%02lu", temp >> 16, cents);
			sprintf(port_temp_str[SP_PORT_A], "%u", port_temp_integer);
			
			if(Print passive)
			{
				$sprintf((char*)$print_buffer, "K=%lu\n", $K);
				//$ itoa( val, (char*)print_buffer, 10);
				print_buffer_length = $$strlen((char*)$print_buffer)$$;
				print_buffer_index = 0;
				start process Print;
				start hyperprocess USART_DataRegisterEmpty_interrupt;
			}
		}
		else
		{
			set state BadData;
		}
		//TEST_PORT &= ~_BV(TEST_PIN);//DEBUG
	}
	state BadData
	{
		if(port_temp[SP_PORT_A] < ADC_TC_OPEN_THRESHOLD)
			set state CalcTemp;
		timeout(TC_OPEN_TIMEOUT)
		{
			sp_port_status[SP_PORT_C] = SP_PORT_ERROR_TC;
			stop process DegasA;
			stop process PortA_Brezenham;
			stop process;
			start process LongBuzz;
		}
	}
}

process CalcTempPortB : background
{
	state FS_START
	{
		set state CalcTemp;
	}
	state CalcTemp
	{
		//Получение значения температуры в порту B
		atomic port_temp[SP_PORT_B] = dd2_adc_ch1;
	
		if(port_temp[SP_PORT_B] < ADC_TC_OPEN_THRESHOLD)
		{
			//32767 - ноль шкалы АЦП
			//2500 - опорное напряжение АЦП в мВ; Умножается на 2.0 в дифференциальном режиме
			//128 - коэффициент усиления в АЦП для сигнала с термопары
			//65535 - максимум шкалы АЦП
			//0.041 - коэффициент Зеебека для линейной модели термопары
			port_temp[SP_PORT_B] = ((port_temp[SP_PORT_B]-32767.0)*2500.0*2.0)/(128.0*65535.0*0.041) + internal_temp;
			dtostrf(port_temp[SP_PORT_B], 6, 2, port_temp_str[SP_PORT_B]);
		}
		else
		{
			set state BadData;
		}
	}
	state BadData
	{
		if(port_temp[SP_PORT_B] < ADC_TC_OPEN_THRESHOLD)
			set state CalcTemp;
		timeout(TC_OPEN_TIMEOUT)
		{
			sp_port_status[SP_PORT_B] = SP_PORT_ERROR_TC;
			stop process DegasB;
			stop process PortB_Brezenham;
			stop process;
			start process LongBuzz;
		}
	}
}

process CalcTempPortC : background
{
	state FS_START
	{
		set state CalcTemp;
	}
	state CalcTemp
	{
		//Получение значения температуры в порту C
		atomic port_temp[SP_PORT_C] = dd3_adc_ch0;
		
		if(port_temp[SP_PORT_C] < ADC_TC_OPEN_THRESHOLD)
		{
			//32767 - ноль шкалы АЦП
			//2500 - опорное напряжение АЦП в мВ; Умножается на 2.0 в дифференциальном режиме
			//128 - коэффициент усиления в АЦП для сигнала с термопары
			//65535 - максимум шкалы АЦП
			//0.041 - коэффициент Зеебека для линейной модели термопары
			port_temp[SP_PORT_C] = ((port_temp[SP_PORT_C]-32767.0)*2500.0*2.0)/(128.0*65535.0*0.041) + internal_temp;
			dtostrf(port_temp[SP_PORT_C], 6, 2, port_temp_str[SP_PORT_C]);
		}
		else
		{
			set state BadData;
		}
	}
	state BadData
	{
		if(port_temp[SP_PORT_C] < ADC_TC_OPEN_THRESHOLD)
			set state CalcTemp;
		timeout(TC_OPEN_TIMEOUT)
		{
			sp_port_status[SP_PORT_C] = SP_PORT_ERROR_TC;
			stop process DegasC;
			stop process PortC_Brezenham;
			stop process;
			start process LongBuzz;
		}
	}
}

#include "adc.ih"
#include "keyboard.ih"

//=============================================================================
//Процесс мигания участком текста ЖК-экрана
//=============================================================================
process Blink : background
{
	state FS_START
	{
		//копирование всего текста экрана
		for(int i=0;i<17;i++)
			Blink_text[i] = LCD_text[i];
			
		set state Show;
	}
	state Hide // символы скрыты
	{
		//замена символов в заданном диапазоне на пробелы
		for(int i=blink_start_pos;i<=blink_end_pos;i++)
			Blink_text[i] = ' ';
		
		timeout(BLINK_PERIOD_MS)
		{
			set state Show;
		}
	}
	state Show // символы отображаются
	{
		//копирование актуальных символов в диапазоне
		for(int i=blink_start_pos;i<=blink_end_pos;i++)
			Blink_text[i] = LCD_text[i];
		
		timeout(BLINK_PERIOD_MS)
		{
			sreg_led &= ~_BV(1);
			set state Hide;
		}
	}
}

//=============================================================================
//Процесс взаимодействия с платой индикации
//Производит обновление ЖК-экрана и светодиодов, опрос клавиатуры
//с заданным периодом (40мс/25Гц)
//=============================================================================
process ShiftRegisters : background
{
	state FS_START
	{
		//Обновление состояния светодиодов
		sreg_led = 0;
		if(SP_PORT_READY == sp_port_status[SP_PORT_A]){}
		else if(SP_PORT_DEGAS == sp_port_status[SP_PORT_A])
			sreg_led |= SREG_LED_A_GRN;
		else if(SP_PORT_FINISHED == sp_port_status[SP_PORT_A])
			sreg_led |= SREG_LED_A_GRN | SREG_LED_A_RED;
		else if(SP_PORT_ERROR_TC == sp_port_status[SP_PORT_A] || SP_PORT_ERROR_HTR == sp_port_status[SP_PORT_A])
			sreg_led |= SREG_LED_A_RED;
			
		if(SP_PORT_READY == sp_port_status[SP_PORT_B]){}
		else if(SP_PORT_DEGAS == sp_port_status[SP_PORT_B])
			sreg_led |= SREG_LED_B_GRN;
		else if(SP_PORT_FINISHED == sp_port_status[SP_PORT_B])
			sreg_led |= SREG_LED_B_GRN | SREG_LED_B_RED;
		else if(SP_PORT_ERROR_TC == sp_port_status[SP_PORT_B] || SP_PORT_ERROR_HTR == sp_port_status[SP_PORT_B])
			sreg_led |= SREG_LED_B_RED;
			
		if(SP_PORT_READY == sp_port_status[SP_PORT_C]){}
		else if(SP_PORT_DEGAS == sp_port_status[SP_PORT_C])
			sreg_led |= SREG_LED_C_GRN;
		else if(SP_PORT_FINISHED == sp_port_status[SP_PORT_C])
			sreg_led |= SREG_LED_C_GRN | SREG_LED_C_RED;
		else if(SP_PORT_ERROR_TC == sp_port_status[SP_PORT_C] || SP_PORT_ERROR_HTR == sp_port_status[SP_PORT_C])
			sreg_led |= SREG_LED_C_RED;
	
		//Обновление текста на ЖК-экране
		if(Blink active)
			UpdateLCD(Blink_text);
		else
			UpdateLCD(LCD_text);
		set state Wait;
	}
	state Wait
	{
		timeout(UI_UPDATE_PERIOD_MS)
		{
			set state FS_START;
		}
	}
}


//=============================================================================
//Процесс короткого звукового сигнала
//=============================================================================
process ShortBuzz : background
{
	state FS_START
	{
		TCCR2 |= _BV(COM20);
		set state Buzz;
	}
	state Buzz
	{
		timeout(SHORT_BUZZ_DURATION_MS)
		{
			TCCR2 &= ~_BV(COM20);
			stop process;
		}
	}
}

//=============================================================================
//Процесс длинного звукового сигнала
//=============================================================================
process LongBuzz : background
{
	state FS_START
	{
		TCCR2 |= _BV(COM20);
		set state Buzz;
	}
	state Buzz
	{
		timeout(LONG_BUZZ_DURATION_MS)
		{
			TCCR2 &= ~_BV(COM20);
			stop process;
		}
	}
}

unsigned char buzz_number;
process Buzz : background
{
	unsigned char i;
	state FS_START
	{
		i = 0;
		set state StartBuzz;
	}
	state StartBuzz
	{
		if(i < buzz_number)
		{
			start process LongBuzz;
			set state Buzz;
		}
		else
			stop process;
	}
	state Buzz
	{
		timeout(LONG_BUZZ_DURATION_MS)
		{
			set state StartBuzz;
		}
	}
}

//=============================================================================
//Процесс выбора порта дегазации
//Обрабатывает события с клавиш выбора порта
//По нажатию устанавливает текущий порт в меню пользовательского интерфейса
//По длительному нажатию запускает или останавливает процесс дегазации в порту
//=============================================================================
process UI_PortSelection : background
{
	state FS_START
	{
		if(button_A_pressed)
		{
			UI_port = SP_PORT_A;
			if(UI_Menu active)
				start process UI_Menu;//сброс процесса меню на начальную страницу
		}
		if(button_B_pressed)
		{
			UI_port = SP_PORT_B;
			if(UI_Menu active)
				start process UI_Menu;//сброс процесса меню на начальную страницу
		}
		if(button_C_pressed)
		{
			UI_port = SP_PORT_C;
			if(UI_Menu active)
				start process UI_Menu;//сброс процесса меню на начальную страницу
		}
		
		
		if(button_A_held)
		{
			if(DegasA active)
			{
				stop process DegasA;
				sp_port_status[SP_PORT_A] = SP_PORT_READY;
			}
			else
			{
				start process DegasA;
				sp_port_status[SP_PORT_A] = SP_PORT_DEGAS;
			}
		}
		if(button_B_held)
		{
			if(DegasB active)
			{
				stop process DegasB;
				sp_port_status[SP_PORT_B] = SP_PORT_READY;
			}
			else
			{
				start process DegasB;
				sp_port_status[SP_PORT_B] = SP_PORT_DEGAS;
			}
		}
		if(button_C_held)
		{
			if(DegasC active)
			{
				stop process DegasC;
				sp_port_status[SP_PORT_C] = SP_PORT_READY;
			}
			else
			{
				start process DegasC;
				sp_port_status[SP_PORT_C] = SP_PORT_DEGAS;
			}
		}
	}
}


process UI_Setup_Switching : background
{
	state FS_START
	{
		if(UI_Setup_Menu active)
			set state InSetup;
		
		else
			set state InUI;
	}
	
	state InUI
	{
		if(setup_switch_combination)
		{
			stop process UI_Menu;
			start process UI_Setup_Menu;
			set state InSetup;
		}
	}
	
	state InSetup
	{
		if(setup_switch_combination)
		{
			stop process UI_Setup_Menu;
			start process UI_Menu;
			set state InUI;
		}
	}
}


#include "ui_menu.ih"
#include "ui_setup_menu.ih"

//=============================================================================
//Процесс дегазации в порту A
//=============================================================================
process DegasA : background 
{
	state FS_START 
	{
		//sreg_led &= ~SREG_LED_A_RED;
		//sreg_led |= SREG_LED_A_GRN;
	} 
	state FS_STOP
	{
		//sreg_led &= ~SREG_LED_A_GRN;
		//sreg_led |= SREG_LED_A_RED;
	}
}

//=============================================================================
//Процесс дегазации в порту B
//=============================================================================
process DegasB : background 
{
	state FS_START 
	{
		//sreg_led &= ~SREG_LED_B_RED;
		//sreg_led |= SREG_LED_B_GRN;
	} 
	state FS_STOP
	{
		//sreg_led &= ~SREG_LED_B_GRN;
		//sreg_led |= SREG_LED_B_RED;
	}
}

//=============================================================================
//Процесс дегазации в порту C
//=============================================================================
process DegasC : background 
{
	state FS_START 
	{
		//sreg_led &= ~SREG_LED_C_RED;
		//sreg_led |= SREG_LED_C_GRN;
	} 
	state FS_STOP
	{
		//sreg_led &= ~SREG_LED_C_GRN;
		//sreg_led |= SREG_LED_C_RED;
	}
}

process TestPrint : background
{
	state FS_START
	{
		$sprintf((char*)$print_buffer, "ADC: %u\n", $number);
		//$ itoa( val, (char*)print_buffer, 10);
		print_buffer_length = $$strlen((char*)$print_buffer)$$;
		print_buffer_index = 0;
		
		start process Print;
		start hyperprocess USART_DataRegisterEmpty_interrupt;
		set state Delay;
	}
	state Delay
	{
		timeout(500)
		{
			set state FS_START;
		}
	}
}

//=============================================================================
//Гиперпроцесс внешнего прерывания по восходящему фронту опорного сигнала сети
//=============================================================================
hyperprocess MAINS_REF_interrupt
{
	vector = INT5_vect;
	register = EIMSK;
	bit = INT5;
}

//=============================================================================
//Процесс управления мощностью нагревателя порта A по алгоритму Брезенхема
//Активируется внешним прерыванием по восходящем фронту сигнала синхронизации 
//сети 100Гц, ширина импульса 760 мкс, центр импульса совпадает с моментом
//пересечения нуля синусоидальным сигналом сети 220 В
//На каждом шаге принимается решение о пропуске очередной полуволны
// - значение мощности нагревателя задается числом от 0 до 1
// - на каждом шаге к ошибке прибавляется заданная мощность
// - если ошибка >= 1, пропускаем полуволну, от ошибки отнимается 1
// - если ошибка < 1, полуволну не пропускаем
//=============================================================================
process PortA_Brezenham : MAINS_REF_interrupt
{
	volatile unsigned int error;
	state FS_START
	{
		portA_power = HEATER_FULL_POWER * 1;
		error = 0;
		//HEATER_PORT &= ~_BV(HEATER_A_PIN);
		set state Brezenham;
	}
	state Brezenham
	{
		error += portA_power;//накопление ошибки
		if(error >= HEATER_FULL_POWER)
		{
			HEATER_PORT &= ~_BV(HEATER_A_PIN);//открытие тиристора - пропускаем полуволну
			error -= HEATER_FULL_POWER;
		}
		else
			HEATER_PORT |= _BV(HEATER_A_PIN);//закрытие тиристора - не пропускаем полуволну
		//set state FS_START;
	} 
	state FS_STOP
	{
		HEATER_PORT |= _BV(HEATER_A_PIN);
	}
}

process PortB_Brezenham : MAINS_REF_interrupt
{
	volatile unsigned int error;
	state FS_START
	{
		
	}
}

process PortC_Brezenham : MAINS_REF_interrupt
{
	volatile unsigned int error;
	state FS_START
	{
		
	}
}

#include "print.ih"






